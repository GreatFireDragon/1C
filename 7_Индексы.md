## 7. Индексы


1. Структуру индексов регистра сведений можно определить:
> с помощью кода получить в отладчике структуру хранения данных
> ТаблицаСоСтруктурой = **ПолучитьСтруктуруХраненияБазыДанных()**;
> ТаблицаСоСтруктурой.Сортировать("Метаданные, ИмяТаблицыХранения")

2. Для периодического Регистра сведений (в том числе подчиненного регистратору) кластерный индекс:
> [Хэш функция разделителей| Независимые разделители] +
> Измерение 1 + [Измерение 2+...] +
> **Период**

3.  Для периодического Регистра сведений подчиненного регистратору
 с периодичностью **по позиции регистратора** кластерный индекс:
 > [Хэш функция разделителей| Независимые разделители] +
> Измерение 1 + [Измерение 2+...] +
> **Период + Регистратор + НомерСтроки**

4. **Кластерный индекс** для баз 1С 8.3 и СУБД MS SQL Server **периодического регистра сведений** (если нет общих реквизитов, являющихся разделителями) начинается с:
> Первого измерения

5. Для ведущего измерения регистра сведений 1С возможность включения индексирования в конфигураторе отключена. Это означает, что:
> **Индексы аналогичны** и создаются автоматически

6. Для **периодического регистра сведений** всегда будет создаваться индекс:
> По периоду

7.  Для чего нужны индексы?
> Повышают производительность **поиска и сортировки** данных
> Повышают **производительность СУБД**
> Ответ: 2 и 3

8. Какие индексы создаются средствами платформы?
> **Неявныцм образом**  при создании объектов; тех или иных настройках конфигурации.
> **Явным образом**, например *Индексировать* или *Ведущее*
> **Кластерный и некластерные**
> Ответ: 1, 2 и 3

9. Что такое кластеризованный индекс?
> Индекс, по которому **отсортированы** и хранятся **строки данных** в таблице

10. Чем кластеризованный индекс отличается от кластерного?
> Это одно и то же

11. Что такое уникальный индекс?
> Обеспечивает **отсутствие повторяющихся значений** ключа индекса

12. Кластерный индекс:
> Может быть **уникальным** и **не уникальным** 
> *(обеспечивается СУБД путем добавления служебных данных)*

13. Уникальный индекс:
> Может быть **либо кластерным**, **либо не кластерным**

14. В чем отличие кластерного индекса от некластерного?
> Кластерные индексы сортируют и хранят строки данных в таблицах
> Некластерные не трогают сами таблицы

15. Обязательно ли наличие индексов?
> Нет

16. Индексирование первого измерения регистра, если это измерение имеет составной тип:
> Может улучшить план запроса
> Ключевое слово *может*, поскольку надо проверить экспериментально

17. Чем **B-tree** отличается от **Binary tree**?
> **B-tree обязательно сбалансировано**, Binary tree — не обязательно
> **B-tree**, в отличие от Binary tree, **может иметь высокую ветвистость**
> **B-tree это обобщение Binary search tree (BST)**
> Ответ: 2, 3 и 4

18. Двоичное дерево поиска (**binary search tree** или **BST**) это двоичное дерево, у которого:
> **Оба поддерева** — левое и правое — являются **двоичными деревьями** поиска
> **Левое** поддерево узла содержит только узлы **с ключами меньше**, чем ключ узла.
> **Правое** поддерево узла содержит только узлы **с ключами больше**, чем ключ узла.
> Ответ: 1, 2 и 3

19. Двоичная куча (**binary heap**) это двоичное дерево, у которого:
> Уровни заполняются **полностью слева направо** без пропусков
> Значения в любой вершине **не меньше** (или **не больше**) её потомков
> Ответ: 1 и 3

20. Структура внутренних и листовых страниц **B-tree**:
> Обычно различается

21. Что такое ссылочная целостность?
> **Качество реляционной БД — отсутствие** в любой её таблице внешних **ключей, ссылающихся на несуществующие кортежи**

22. Что такое кортеж?
> Упорядоченный набор **фиксированной длины**

23. Что такое внешний ключ (**foreign key**)?
> Набор атрибутов одной таблицы, являющихся ключом другой *(или той же самой)* таблицы

24. Какие требования предъявляются к потенциальному ключу в реляционной модели данных?
> Потенциальный ключ (candidate key) — подмножество атрибутов, удовлетворяющее требованиям **уникальности** и **минимальности (несократимости)**
> Ответ: 1 и 2

25. Что такое целостность базы данных (**database integrity**)?
> Соответствие имеющихся в БД информации её внутренней логике, структуре и всем её явно заданным правилам

26. Что такое первичный ключ (**primary key**)?
> Один из потенциальных ключей, выбранный в качестве основного ключа (или ключа по умолчанию)

27. Часть индексов могут содержать значения хэш-функции знаечний разделителей. Когда это используется? `[ОРРХ | ОРНР1 +]`
> Если тип разделителя — строка
> или разделитель независимый и совместный
> или разделителей больше одного

28. Как можно увидеть, включен ли **общий реквезит** в состав индекса?
> Только с помощью MS SQL Mangement Studio
> `Справка: При использовании общего реквизита к большинству индексов первым столбцом ключа индекса добавляется DataSeparationHash (значение хэш-функции разделителей). Этого факта, к сожалению, через ПолучитьСтруктуруЗначенияБазыДанных() вы тоже не увидете, и про него тоже надо помнить.`

29. Общий реквезит, последовательность общих реквезитов, хэш функция общих реквезитов включается в состав индекса:
> Первым полем (полями)

30. Если в конфигураторе используется более одного общего реквизита, являющегося независимым разделителем (**ОРНР**):
> В часть индексов включается их последовательность `[ОРНР1 + ОРНР2 + ... +]`
> В часть индексов включается их хэш-функция `[ОРРХ]`
> Ответ: 1 и 4

31. Для НЕП. регистра сведений, **подчиненого регистратору**, кластерный индекс:
> [ОРНР1 + ... +] Регистратор + НомерСтроки

32.  Для: `справочников, документов, планов видов характеристик, планов обменов, планов счетов, планов видов расчета, бизнес-процессов, задач` — кластерный индекс:
> [ОРНР1 + ... +] Ссылка

33. Часть индексов могут содержать значения хэш-функций разделителей. Что является альтернативой?
> В конфигурации определен единственный независимый разделитель, тип которого **не Строка**. Тогда в качестве индекса будет использоваться **его значение**. 

34. Каким по счету полем разделитель итогов (**Splitter**) включается в состам индекса?
> [ОРРХ | ОРНР1 +] Период + Измерение1 + ... + ИзмерениеN +[DimHash] + **[Splitter]** 

35. В каком случае разделитель итогов (**Splitter**) включается в состам индекса?
> Если у регистра разрешено разделение итогов, и неважно — включено оно или нет.

36. Как можно увидеть, включен ли разделитель итогов (**Splitter**) в состав индекса?
> С помощью **MS SQL Mangement Studio**
> Через **ПолучитьСтруктуруХраненияБазыДанных()**
> Ответ: 1 и 2

37. Применяется ли разделитель итогов (**Splitter**) в индексе таблицы оборотов регистра накопления?
> Да, только для регистра типа **Обороты**

38. Применяется ли разделитель итогов (**Splitter**) в индексе таблицы остатков регистра накопления?
> Да, только для регистра типа **Остатки**

39. **По какой схеме** при индексировании измерения ИзмерениеN **регистра накопления, регистра бухгалтерии, регистра сведений** с периодичностью "*по позиции регистратора*" будет создан **индекс по таблице движений**?
> [ОРРХ | ОРНР1 +] **ИзмерениеN** + Период + Регистратор + НомерСтроки
> *Если вычеркнуть ИзмерениеN, получится кластерный индекс таких регистров*

40. Индексы некоторых регистров содержат поле **SimpleKey**. Что это?
> Короткий ключ записи регистра. Поле **присутствует у непериодических** регистров сведений, имеющих хотя бы одно измерение.

41. Индексы некоторых регистров содержат поле **Splitter**. Что это?
> Если для регистра разрешено разделение итогов в конфигураторе (не важно включено или нет)
> **Splitter — Разделитель итогов**  Применяется у регистров Накопления и регистров Бухгалтерии

42. **Некоторые индексы первым полем содержат поле** с именем, неотносящимся к колонкам таблиц регистра, и не являющимся ни периодом, ни регистратором. В составе имени поля есть **Field**. Что это может быть?
> **ОРНР** имеет **Fld (Field)** в составе имени
> Общий реквизит, являющийся независимым разделителем

43. Можно ли индексировать **ресурсы регистра**?
> Можно только у регистра сведений

44. Можно ли индексировать **реквизиты регистра**?
> Можно у регистров всех типов

45. Что и куда добавляется в индекс, создаваемый для реквизита, если для реквизита справочника вместо **Индексировать** задать **Индексировать с доп. упорядочиванием**?
> Если **Длина кода не равно 0**, а свойство **Основное представление равно В виде кода**, тогда в индекс по реквизиту войдёт войдёт **Реквизит + Код** вместо **Реквизит**
> 
> Если **Длина наименования не равно 0**, а свойство **Основное представление равно В виде наименования**, тогда в индекс по реквизиту войдёт войдёт **Реквизит + Наименование** вместо **Реквизит**
> 
> Ответ: 1 и 2

46. Можно ли индексировать **измерение регистра**?
> Да, если оно не ведущее

47. **По какой схеме** при индексировании измерения ИзмерениеN **периодического регистра сведений** (НЕ с периодичностью "по позиции регистратора") будет создан индекс? ИзмерениеN не первое и не единственное.
> [ОРРХ | ОРНР1 +] **ИзмерениеN** + **Период** + Измерение1 + [Измерение2 +...]

48. **По какой схеме** при индексировании измерения ИзмерениеN **непериодического регистра сведений** будет создан индекс? ИзмерениеN не первое и не единственное.
> [ОРРХ | ОРНР1 +] **ИзмерениеN** + Измерение1 + [Измерение2 +...]

49. Некоторые индексы первым полем содержат поле с именем **DataSeparationHash**. Что это может быть?
> DataSeparationHash — **ОРРХ**
> **Хэш-функция общих реквизитов**, являющихся независимыми разделителями

## Заметки
ОРРХ — DataSeparationHash
ОРНР — Fld (Field)




























> Written with [StackEdit](https://stackedit.io/).
